// Generated by CoffeeScript 1.4.0
(function() {
  var BLANK, BOARDSIZE, GROUPHEIGHT, GROUPWIDTH, SudokuGrid, init, solver, ui,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  GROUPWIDTH = 3;

  GROUPHEIGHT = 3;

  BOARDSIZE = GROUPWIDTH * GROUPHEIGHT;

  BLANK = "";

  SudokuGrid = (function() {

    function SudokuGrid() {
      var x, y, _i, _results;
      this.grid = (function() {
        var _i, _results;
        _results = [];
        for (x = _i = 0; 0 <= BOARDSIZE ? _i < BOARDSIZE : _i > BOARDSIZE; x = 0 <= BOARDSIZE ? ++_i : --_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (y = _j = 0; 0 <= BOARDSIZE ? _j < BOARDSIZE : _j > BOARDSIZE; y = 0 <= BOARDSIZE ? ++_j : --_j) {
              _results1.push(void 0);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      this.legalValues = (function() {
        _results = [];
        for (var _i = 1; 1 <= BOARDSIZE ? _i <= BOARDSIZE : _i >= BOARDSIZE; 1 <= BOARDSIZE ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    }

    SudokuGrid.prototype.setFromSelector = function(selector) {
      var _this = this;
      return selector.each(function(index, element) {
        var value, x, y;
        x = index % BOARDSIZE;
        y = Math.floor(index / BOARDSIZE);
        value = $(element).val();
        if (value !== "") {
          return _this.grid[x][y] = parseInt(value, 10);
        }
      });
    };

    SudokuGrid.prototype.setFromString = function(string) {
      var i, value, x, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        value = parseInt(string.charAt(i, 10));
        if (__indexOf.call(this.legalValues, value) >= 0) {
          x = i % BOARDSIZE;
          y = Math.floor(i / BOARDSIZE);
          _results.push(this.grid[x][y] = value);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    SudokuGrid.prototype.getAsString = function() {
      var string, x, y, _i, _j;
      string = "";
      for (x = _i = 0; 0 <= BOARDSIZE ? _i < BOARDSIZE : _i > BOARDSIZE; x = 0 <= BOARDSIZE ? ++_i : --_i) {
        for (y = _j = 0; 0 <= BOARDSIZE ? _j < BOARDSIZE : _j > BOARDSIZE; y = 0 <= BOARDSIZE ? ++_j : --_j) {
          string = string + (this.grid[x][y] || ".");
        }
      }
      return string;
    };

    SudokuGrid.prototype.clear = function() {
      var i, j, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= BOARDSIZE ? _i < BOARDSIZE : _i > BOARDSIZE; i = 0 <= BOARDSIZE ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (j = _j = 0; 0 <= BOARDSIZE ? _j < BOARDSIZE : _j > BOARDSIZE; j = 0 <= BOARDSIZE ? ++_j : --_j) {
            _results1.push(this.grid[i][j] = void 0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    SudokuGrid.prototype.getRow = function(y) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= BOARDSIZE ? _i < BOARDSIZE : _i > BOARDSIZE; i = 0 <= BOARDSIZE ? ++_i : --_i) {
        _results.push(this.grid[i][y]);
      }
      return _results;
    };

    SudokuGrid.prototype.getColumn = function(x) {
      return this.grid[x];
    };

    SudokuGrid.prototype.getGroup = function(x, y) {
      var group, i, j, _i, _j, _ref, _ref1, _ref2, _ref3;
      group = [];
      for (i = _i = _ref = x * GROUPWIDTH, _ref1 = (x + 1) * GROUPWIDTH; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        for (j = _j = _ref2 = y * GROUPHEIGHT, _ref3 = (y + 1) * GROUPHEIGHT; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; j = _ref2 <= _ref3 ? ++_j : --_j) {
          group.push(this.grid[i][j]);
        }
      }
      return group;
    };

    SudokuGrid.prototype.getEmptyPositions = function() {
      var emptyPositions, x, y, _i, _j;
      emptyPositions = [];
      for (y = _i = 0; 0 <= BOARDSIZE ? _i < BOARDSIZE : _i > BOARDSIZE; y = 0 <= BOARDSIZE ? ++_i : --_i) {
        for (x = _j = 0; 0 <= BOARDSIZE ? _j < BOARDSIZE : _j > BOARDSIZE; x = 0 <= BOARDSIZE ? ++_j : --_j) {
          if (this.grid[x][y] === void 0) {
            emptyPositions.push({
              x: x,
              y: y
            });
          }
        }
      }
      return emptyPositions;
    };

    SudokuGrid.prototype.isFull = function() {
      var x, y, _i, _j;
      for (x = _i = 0; 0 <= BOARDSIZE ? _i < BOARDSIZE : _i > BOARDSIZE; x = 0 <= BOARDSIZE ? ++_i : --_i) {
        for (y = _j = 0; 0 <= BOARDSIZE ? _j < BOARDSIZE : _j > BOARDSIZE; y = 0 <= BOARDSIZE ? ++_j : --_j) {
          if (this.grid[x][y] === void 0) {
            return false;
          }
        }
      }
      return true;
    };

    SudokuGrid.prototype.getPossibilities = function(x, y) {
      var groupX, groupY, possibilities, value, _i, _len, _ref;
      possibilities = [];
      _ref = this.legalValues;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        value = _ref[_i];
        groupX = Math.floor(x / GROUPWIDTH);
        groupY = Math.floor(y / GROUPHEIGHT);
        if (__indexOf.call(this.getRow(y), value) < 0) {
          if (__indexOf.call(this.getColumn(x), value) < 0) {
            if (__indexOf.call(this.getGroup(groupX, groupY), value) < 0) {
              possibilities.push(value);
            }
          }
        }
      }
      return possibilities;
    };

    SudokuGrid.prototype.isRegionValid = function(region) {
      var seenSoFar, value, _i, _len;
      seenSoFar = {};
      for (_i = 0, _len = region.length; _i < _len; _i++) {
        value = region[_i];
        if (value === void 0) {
          continue;
        }
        if (value in seenSoFar) {
          return false;
        } else {
          seenSoFar[value] = true;
        }
      }
      return true;
    };

    SudokuGrid.prototype.isValid = function() {
      var column, group, i, j, row, _i, _j, _k, _l;
      for (i = _i = 0; 0 <= BOARDSIZE ? _i < BOARDSIZE : _i > BOARDSIZE; i = 0 <= BOARDSIZE ? ++_i : --_i) {
        row = this.getRow(i);
        if (!this.isRegionValid(row)) {
          return false;
        }
      }
      for (j = _j = 0; 0 <= BOARDSIZE ? _j < BOARDSIZE : _j > BOARDSIZE; j = 0 <= BOARDSIZE ? ++_j : --_j) {
        column = this.getColumn(j);
        if (!this.isRegionValid(column)) {
          return false;
        }
      }
      for (i = _k = 0; 0 <= GROUPWIDTH ? _k < GROUPWIDTH : _k > GROUPWIDTH; i = 0 <= GROUPWIDTH ? ++_k : --_k) {
        for (j = _l = 0; 0 <= GROUPWIDTH ? _l < GROUPWIDTH : _l > GROUPWIDTH; j = 0 <= GROUPWIDTH ? ++_l : --_l) {
          group = this.getGroup(i, j);
          if (!this.isRegionValid(group)) {
            return false;
          }
        }
      }
      return true;
    };

    return SudokuGrid;

  })();

  ui = {
    clearTable: function() {
      var blankTable;
      ui.removeUserValuesClass();
      $("#invalid_table").hide();
      blankTable = new SudokuGrid();
      return ui.setTable(blankTable);
    },
    addUserValuesClass: function() {
      return $("#sudoku td input[value!='']").addClass("user_value");
    },
    removeUserValuesClass: function() {
      return $(".user_value").removeClass("user_value");
    },
    checkTableIsValid: function() {
      var currentTable;
      currentTable = new SudokuGrid();
      currentTable.setFromSelector($("#sudoku input"));
      if (!currentTable.isValid()) {
        return $("#invalid_table").show();
      } else {
        return $("#invalid_table").hide();
      }
    },
    getTable: function() {
      var grid;
      grid = new SudokuGrid();
      grid.setFromSelector($('#sudoku input'));
      return grid;
    },
    setTable: function(table) {
      return $("#sudoku tr").each(function(y, element) {
        return $("input", $(element)).each(function(x, element) {
          return $(element).val(table.grid[x][y]);
        });
      });
    }
  };

  solver = {
    getMostContstrainedPosition: function(grid) {
      var mostConstrainedPosition, possibilitiesHere, x, y, _i, _len, _ref, _ref1;
      mostConstrainedPosition = null;
      _ref = grid.getEmptyPositions();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1.x, y = _ref1.y;
        possibilitiesHere = grid.getPossibilities(x, y);
        if (possibilitiesHere.length === 0) {
          return {
            x: x,
            y: y,
            possibilities: []
          };
        }
        if (!mostConstrainedPosition || possibilitiesHere.length < mostConstrainedPosition.possibilities.length) {
          mostConstrainedPosition = {
            x: x,
            y: y,
            possibilities: possibilitiesHere
          };
        }
      }
      return mostConstrainedPosition;
    },
    findSolution: function(grid) {
      var possibilities, possibility, result, x, y, _i, _len, _ref;
      if (grid.isFull()) {
        return {
          isSolution: true,
          table: grid
        };
      }
      _ref = solver.getMostContstrainedPosition(grid), x = _ref.x, y = _ref.y, possibilities = _ref.possibilities;
      for (_i = 0, _len = possibilities.length; _i < _len; _i++) {
        possibility = possibilities[_i];
        grid.grid[x][y] = possibility;
        result = solver.findSolution(grid);
        if (result.isSolution) {
          return result;
        }
      }
      grid.grid[x][y] = void 0;
      return {
        isSolution: false,
        table: grid
      };
    }
  };

  init = function() {
    $('#solve').click(function() {
      var currentTable, endTime, result, solvedTable, startTime;
      ui.addUserValuesClass();
      currentTable = ui.getTable();
      startTime = new Date().getTime();
      result = solver.findSolution(currentTable);
      endTime = new Date().getTime();
      if (typeof console !== "undefined" && console !== null) {
        console.log("Solved in " + (endTime - startTime) + " milliseconds.");
      }
      if (result.isSolution) {
        solvedTable = result.table;
        return ui.setTable(solvedTable);
      } else {
        return ui.removeUserValuesClass;
      }
    });
    $('#clear_table').click(function() {
      return ui.clearTable();
    });
    $('#import_puzzle').click(function() {
      var puzzleString, table;
      ui.clearTable();
      puzzleString = prompt("Enter a puzzle string:");
      table = new SudokuGrid();
      table.setFromString(puzzleString);
      ui.setTable(table);
      return ui.checkTableIsValid();
    });
    $('#export_puzzle').click(function() {
      return alert(ui.getTable().getAsString());
    });
    return $("#sudoku input").keyup(function() {
      return ui.checkTableIsValid();
    });
  };

  init();

  window.ui = ui;

  window.solver = solver;

  window.SudokuGrid = SudokuGrid;

}).call(this);
